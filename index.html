<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Snake Game with Futuristic Menu and Music Toggle</title>
<style>
  body {
    margin: 0;
    height: 100vh;
    font-family: 'Arial', sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    overflow: hidden;
  }
  
  /* Animated snake patterns in background */
  body::before,
  body::after {
    content: '';
    position: fixed;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: -1;
  }
  
  body::before {
    background-image: 
      url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200"><path d="M20,100 Q50,80 80,100 T140,100 T200,100" stroke="rgba(0,0,0,0.15)" stroke-width="25" fill="none" stroke-linecap="round"/><circle cx="25" cy="100" r="15" fill="rgba(0,0,0,0.15)"/><ellipse cx="18" cy="95" rx="3" ry="5" fill="rgba(255,255,255,0.3)"/></svg>');
    animation: snakeMove1 20s linear infinite;
    opacity: 0.6;
  }
  
  body::after {
    background-image: 
      url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200"><path d="M0,100 Q30,120 60,100 T120,100 T180,100" stroke="rgba(0,0,0,0.12)" stroke-width="22" fill="none" stroke-linecap="round"/><circle cx="185" cy="100" r="13" fill="rgba(0,0,0,0.12)"/><ellipse cx="190" cy="96" rx="3" ry="4" fill="rgba(255,255,255,0.25)"/></svg>');
    animation: snakeMove2 25s linear infinite reverse;
    opacity: 0.5;
  }
  
@keyframes snakeMove1 {
    0% { 
      transform: translateX(-200px) translateY(-200px) scaleX(1); 
    }
    25% { 
      transform: translateX(25vw) translateY(25vh) scaleX(1.1) scaleY(0.95); 
    }
    50% { 
      transform: translateX(50vw) translateY(50vh) scaleX(0.9) scaleY(1.05); 
    }
    75% { 
      transform: translateX(75vw) translateY(75vh) scaleX(1.1) scaleY(0.95); 
    }
    100% { 
      transform: translateX(100vw) translateY(100vh) scaleX(1); 
    }
  }
  
  @keyframes snakeMove2 {
    0% { 
      transform: translateX(100vw) translateY(-200px) rotate(180deg) scaleX(1); 
    }
    25% { 
      transform: translateX(75vw) translateY(25vh) rotate(180deg) scaleX(0.9) scaleY(1.05); 
    }
    50% { 
      transform: translateX(50vw) translateY(50vh) rotate(180deg) scaleX(1.1) scaleY(0.95); 
    }
    75% { 
      transform: translateX(25vw) translateY(75vh) rotate(180deg) scaleX(0.9) scaleY(1.05); 
    }
    100% { 
      transform: translateX(-200px) translateY(100vh) rotate(180deg) scaleX(1); 
    }
  }

  /* Main menu styles - futuristic bluish */
  #menu {
    background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
    backdrop-filter: blur(15px);
    border-radius: 20px;
    padding: 40px 60px;
    box-shadow: 0 0 40px rgba(0, 191, 255, 0.6);
    text-align: center;
    color: #fff;
    width: 80%;
    max-width: 400px;
  }

  #menu h1 {
    font-family: 'Orbitron', Arial, sans-serif;
    font-size: 2.5em;
    margin-bottom: 20px;
    letter-spacing: 2px;
    color: #00ffff;
  }

  /* Map selection buttons styling */
  .map-button {
    display: block;
    width: 100%;
    padding: 15px;
    margin: 10px 0;
    font-size: 1.2em;
    border: none;
    border-radius: 12px;
    cursor: pointer;
    background: linear-gradient(135deg, #00ffff, #007fff);
    color: #fff;
    transition: all 0.3s ease;
    box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
  }

  .map-button:hover {
    background: linear-gradient(135deg, #007fff, #00ffff);
    box-shadow: 0 0 25px rgba(0, 255, 255, 0.8);
    transform: translateY(-3px);
  }

  /* Welcome overlay styles */
  #welcomeScreen {
    display: flex;
  }

  /* Game container styles */
  #gameContainer {
    display: none;
    position: relative;
    width: 600px;
    height: 600px;
    border: 30px solid #1a1a1a;
    box-shadow: 
      0 0 50px rgba(0,0,0,0.9),
      inset 0 0 40px rgba(0,0,0,0.6),
      0 0 100px rgba(0,255,65,0.3);
    background: #000;
    overflow: hidden;
  }

  #gameContainer::before {
    content: '';
    position: absolute;
    top: -30px;
    left: -30px;
    right: -30px;
    bottom: -30px;
    background: 
      repeating-linear-gradient(
        90deg,
        #2d5016 0px,
        #3a6b1f 8px,
        #1a3d0a 16px,
        #2d5016 24px,
        #4a7c25 32px,
        #2d5016 40px
      ),
      repeating-linear-gradient(
        0deg,
        rgba(0,0,0,0.3) 0px,
        transparent 4px,
        rgba(0,0,0,0.3) 8px
      );
    z-index: -1;
    pointer-events: none;
  }

  #score {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    color: #fff;
    font-size: 24px;
    padding: 8px 16px;
    background: rgba(0,0,0,0.5);
    border-radius: 8px;
    font-family: Arial, sans-serif;
    z-index: 1;
  }

  canvas {
    display: block;
    width: 100%;
    height: 100%;
  }

  /* Style for the small fixed music toggle button at bottom right */
  #musicToggle {
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 60px;
    height: 30px;
    font-size: 0.8em;
    padding: 0;
    margin: 0;
    border: none;
    border-radius: 6px;
    background: linear-gradient(135deg, #00ffff, #007fff);
    color: #fff;
    cursor: pointer;
    box-shadow: 0 0 10px rgba(0,255,255,0.7);
    z-index: 999;
    transition: all 0.3s ease;
  }

  #musicToggle:hover {
    background: linear-gradient(135deg, #007fff, #00ffff);
    box-shadow: 0 0 15px rgba(0,255,255,1);
    transform: translateY(-2px);
  }
</style>
</head>
<body>

<!-- Background music and toggle button -->
<audio id="backgroundMusic" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3" loop volume="0.2" style="display:none;"></audio>
<button id="musicToggle">Music</button>

<!-- Main menu -->
<div id="welcomeScreen">
  <div id="menu">
    <h1>Rafay's Snake Game</h1>
    <div style="margin-top:20px;">Select a Map:</div>
    <button class="map-button" data-speed="150" data-map="beginner">Beginner</button>
    <button class="map-button" data-speed="100" data-map="normal">Normal</button>
    <button class="map-button" data-speed="30" data-map="advanced">Advanced</button>
  </div>
</div>

<!-- Game container -->
<div id="gameContainer">
  <div id="score">Score: 0</div>
  <canvas id="gameCanvas" width="600" height="600"></canvas>
</div>

<script>
const welcomeScreen = document.getElementById('welcomeScreen');
const startButtons = document.querySelectorAll('.map-button');
const gameContainer = document.getElementById('gameContainer');
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreDiv = document.getElementById('score');
const music = document.getElementById('backgroundMusic');
const musicToggleBtn = document.getElementById('musicToggle');

let gameSpeed = 100;
let mapType = 'normal';
let snake, direction, food, score, gameOver, gameInterval;

// Set background based on map type with snake patterns
function setBackground() {
  if (mapType === 'beginner') {
    document.body.style.background = 'linear-gradient(135deg, #FFD700, #FFFF00)';
    document.body.style.backgroundImage = `
      repeating-linear-gradient(45deg, transparent, transparent 35px, rgba(0,0,0,0.05) 35px, rgba(0,0,0,0.05) 70px),
      repeating-linear-gradient(-45deg, transparent, transparent 35px, rgba(0,0,0,0.03) 35px, rgba(0,0,0,0.03) 70px)
    `;
  } else if (mapType === 'normal') {
    document.body.style.background = 'linear-gradient(135deg, #AA0114, #B40404)';
    document.body.style.backgroundImage = `
      repeating-linear-gradient(45deg, transparent, transparent 35px, rgba(0,0,0,0.1) 35px, rgba(0,0,0,0.1) 70px),
      repeating-linear-gradient(-45deg, transparent, transparent 35px, rgba(0,0,0,0.08) 35px, rgba(0,0,0,0.08) 70px)
    `;
  } else if (mapType === 'advanced') {
    document.body.style.background = 'linear-gradient(135deg, #50C878, #008000)';
    document.body.style.backgroundImage = `
      repeating-linear-gradient(45deg, transparent, transparent 35px, rgba(0,0,0,0.1) 35px, rgba(0,0,0,0.1) 70px),
      repeating-linear-gradient(-45deg, transparent, transparent 35px, rgba(0,0,0,0.08) 35px, rgba(0,0,0,0.08) 70px)
    `;
  }
}

// Start game when map is selected
startButtons.forEach(btn => {
  btn.onclick = () => {
    gameSpeed = parseInt(btn.getAttribute('data-speed'));
    mapType = btn.getAttribute('data-map');
    setBackground();
    welcomeScreen.style.display = 'none';
    gameContainer.style.display = 'block';
    startGame();
  };
});

// Toggle music on button click
let musicStarted = false;
musicToggleBtn.onclick = () => {
  if (!musicStarted) {
    music.volume = 0.2;
    music.play();
    musicStarted = true;
  } else {
    if (music.paused) {
      music.play();
    } else {
      music.pause();
    }
  }
};

document.addEventListener('keydown', changeDirection);

function spawnFood() {
  let newFood;
  do {
    newFood = {
      x: Math.floor(Math.random() * (canvas.width / 20)),
      y: Math.floor(Math.random() * (canvas.height / 20))
    };
  } while (
    snake.some(s => s.x === newFood.x && s.y === newFood.y)
  );
  return newFood;
}

function startGame() {
  snake = [{x: 10, y: 10}];
  direction = {x: 1, y: 0};
  food = spawnFood();
  score = 0;
  scoreDiv.innerText = 'Score: 0';
  gameOver = false;
  clearInterval(gameInterval);
  gameInterval = setInterval(update, gameSpeed);
}

function changeDirection(e) {
  const key = e.key;
  if (key === 'ArrowUp' && direction.y !== 1) {
    direction = {x: 0, y: -1};
  } else if (key === 'ArrowDown' && direction.y !== -1) {
    direction = {x: 0, y: 1};
  } else if (key === 'ArrowLeft' && direction.x !== 1) {
    direction = {x: -1, y: 0};
  } else if (key === 'ArrowRight' && direction.x !== -1) {
    direction = {x: 1, y: 0};
  }
}

function update() {
  if (gameOver) {
    alert('Game Over! Your score: ' + score);
    clearInterval(gameInterval);
    return;
  }

  const head = {x: snake[0].x + direction.x, y: snake[0].y + direction.y};
  const widthLimit = canvas.width / 20;
  const heightLimit = canvas.height / 20;

  if (head.x < 0 || head.x >= widthLimit || head.y < 0 || head.y >= heightLimit) {
    gameOver = true;
  }
  if (snake.some(s => s.x === head.x && s.y === head.y)) {
    gameOver = true;
  }

  if (gameOver) {
    alert('Game Over! Your score: ' + score);
    clearInterval(gameInterval);
    return;
  }

  snake.unshift(head);
  if (head.x === food.x && head.y === food.y) {
    score++;
    scoreDiv.innerText = 'Score: ' + score;
    food = spawnFood();
  } else {
    snake.pop();
  }

  draw();
}

function draw() {
  // Dark background with animated scanlines
  const bgGradient = ctx.createRadialGradient(300, 300, 50, 300, 300, 400);
  bgGradient.addColorStop(0, '#0d0d0d');
  bgGradient.addColorStop(1, '#000000');
  ctx.fillStyle = bgGradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Subtle grid with glow
  ctx.strokeStyle = 'rgba(0, 255, 65, 0.05)';
  ctx.lineWidth = 1;
  for (let i = 0; i <= canvas.width; i += 20) {
    ctx.beginPath();
    ctx.moveTo(i, 0);
    ctx.lineTo(i, canvas.height);
    ctx.stroke();
  }
  for (let i = 0; i <= canvas.height; i += 20) {
    ctx.beginPath();
    ctx.moveTo(0, i);
    ctx.lineTo(canvas.width, i);
    ctx.stroke();
  }
  
  // Draw snake
  for (let i = snake.length - 1; i >= 0; i--) {
    const s = snake[i];
    const x = s.x * 20;
    const y = s.y * 20;
    const isHead = i === 0;
    
    ctx.save();
    
    // Calculate fade effect for tail
    const fadeRatio = 1 - (i / snake.length) * 0.5;
    
    if (isHead) {
      // PREMIUM HEAD DESIGN
      // Outer glow layers
      ctx.shadowColor = '#00ff41';
      ctx.shadowBlur = 30;
      ctx.fillStyle = 'rgba(0, 255, 65, 0.3)';
      ctx.beginPath();
      ctx.roundRect(x - 2, y - 2, 24, 24, 8);
      ctx.fill();
      
      // Main head gradient
      const headGrad = ctx.createLinearGradient(x, y, x + 20, y + 20);
      headGrad.addColorStop(0, '#00ff88');
      headGrad.addColorStop(0.5, '#00ff41');
      headGrad.addColorStop(1, '#00dd35');
      ctx.fillStyle = headGrad;
      ctx.shadowBlur = 25;
      ctx.beginPath();
      ctx.roundRect(x + 1, y + 1, 18, 18, 7);
      ctx.fill();
      
      // Inner highlight layer
      ctx.shadowBlur = 0;
      const highlightGrad = ctx.createRadialGradient(x + 6, y + 6, 0, x + 10, y + 10, 12);
      highlightGrad.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
      highlightGrad.addColorStop(0.5, 'rgba(255, 255, 255, 0.1)');
      highlightGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
      ctx.fillStyle = highlightGrad;
      ctx.beginPath();
      ctx.roundRect(x + 2, y + 2, 16, 16, 6);
      ctx.fill();
      
      // Border accent
      ctx.strokeStyle = '#00ffaa';
      ctx.lineWidth = 2;
      ctx.shadowColor = '#00ffaa';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.roundRect(x + 2.5, y + 2.5, 15, 15, 6);
      ctx.stroke();
      
      // Scale pattern on head
      ctx.shadowBlur = 0;
      ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
      for (let sy = 0; sy < 2; sy++) {
        for (let sx = 0; sx < 2; sx++) {
          ctx.beginPath();
          ctx.arc(x + 6 + sx * 8, y + 6 + sy * 8, 2.5, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      // Snake head features based on direction
      let mouthX, mouthY, tongueX, tongueY, eyeX, eyeY;
      
      if (direction.x === 1) { // Right
        eyeX = x + 13; eyeY = y + 8;
        mouthX = x + 16; mouthY = y + 12;
        tongueX = x + 19; tongueY = y + 12;
      } else if (direction.x === -1) { // Left
        eyeX = x + 7; eyeY = y + 8;
        mouthX = x + 4; mouthY = y + 12;
        tongueX = x + 1; tongueY = y + 12;
      } else if (direction.y === 1) { // Down
        eyeX = x + 12; eyeY = y + 13;
        mouthX = x + 8; mouthY = y + 16;
        tongueX = x + 8; tongueY = y + 19;
      } else { // Up
        eyeX = x + 12; eyeY = y + 7;
        mouthX = x + 8; mouthY = y + 4;
        tongueX = x + 8; tongueY = y + 1;
      }
      
      // Single eye (more snake-like)
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#ffff00';
      ctx.beginPath();
      ctx.arc(eyeX, eyeY, 4, 0, Math.PI * 2);
      ctx.fill();
      
      // Slit pupil
      ctx.fillStyle = '#000000';
      if (direction.y !== 0) {
        ctx.fillRect(eyeX - 0.8, eyeY - 4, 1.6, 8);
      } else {
        ctx.fillRect(eyeX - 4, eyeY - 0.8, 8, 1.6);
      }
      
      // Eye shine
      ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
      ctx.beginPath();
      ctx.arc(eyeX - 1, eyeY - 1, 1.5, 0, Math.PI * 2);
      ctx.fill();
      
      // Mouth
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      if (direction.x === 1) {
        ctx.arc(mouthX - 2, mouthY, 3, -Math.PI/4, Math.PI/4);
      } else if (direction.x === -1) {
        ctx.arc(mouthX + 2, mouthY, 3, Math.PI*3/4, Math.PI*5/4);
      } else if (direction.y === 1) {
        ctx.arc(mouthX, mouthY - 2, 3, Math.PI/4, Math.PI*3/4);
      } else {
        ctx.arc(mouthX, mouthY + 2, 3, -Math.PI*3/4, -Math.PI/4);
      }
      ctx.stroke();
      
      // Forked tongue
      ctx.strokeStyle = '#ff0055';
      ctx.lineWidth = 1.5;
      ctx.shadowColor = '#ff0055';
      ctx.shadowBlur = 5;
      
      if (direction.x !== 0) {
        ctx.beginPath();
        ctx.moveTo(mouthX, mouthY);
        ctx.lineTo(tongueX, tongueY);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(tongueX, tongueY);
        ctx.lineTo(tongueX + (direction.x * 2), tongueY - 2);
        ctx.moveTo(tongueX, tongueY);
        ctx.lineTo(tongueX + (direction.x * 2), tongueY + 2);
        ctx.stroke();
      } else {
        ctx.beginPath();
        ctx.moveTo(mouthX, mouthY);
        ctx.lineTo(tongueX, tongueY);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(tongueX, tongueY);
        ctx.lineTo(tongueX - 2, tongueY + (direction.y * 2));
        ctx.moveTo(tongueX, tongueY);
        ctx.lineTo(tongueX + 2, tongueY + (direction.y * 2));
        ctx.stroke();
      }
      
    } else {
      // PREMIUM BODY DESIGN
      // Outer glow
      ctx.shadowColor = `rgba(0, 255, 65, ${0.3 * fadeRatio})`;
      ctx.shadowBlur = 20 * fadeRatio;
      ctx.fillStyle = `rgba(0, 255, 65, ${0.15 * fadeRatio})`;
      ctx.beginPath();
      ctx.roundRect(x - 1, y - 1, 22, 22, 7);
      ctx.fill();
      
      // Main body with gradient
      const bodyGrad = ctx.createRadialGradient(x + 10, y + 10, 2, x + 10, y + 10, 12);
      bodyGrad.addColorStop(0, `rgba(0, 255, 65, ${fadeRatio})`);
      bodyGrad.addColorStop(0.7, `rgba(0, 200, 50, ${fadeRatio * 0.8})`);
      bodyGrad.addColorStop(1, `rgba(0, 150, 35, ${fadeRatio * 0.6})`);
      ctx.fillStyle = bodyGrad;
      ctx.shadowBlur = 15 * fadeRatio;
      ctx.beginPath();
      ctx.roundRect(x + 2, y + 2, 16, 16, 6);
      ctx.fill();
      
      // Highlight
      ctx.shadowBlur = 0;
      const bodyHighlight = ctx.createRadialGradient(x + 6, y + 6, 0, x + 8, y + 8, 6);
      bodyHighlight.addColorStop(0, `rgba(255, 255, 255, ${0.3 * fadeRatio})`);
      bodyHighlight.addColorStop(1, 'rgba(255, 255, 255, 0)');
      ctx.fillStyle = bodyHighlight;
      ctx.beginPath();
      ctx.arc(x + 7, y + 7, 5, 0, Math.PI * 2);
      ctx.fill();
      
      // Scale pattern
      ctx.fillStyle = `rgba(0, 0, 0, ${0.2 * fadeRatio})`;
      ctx.beginPath();
      ctx.arc(x + 10, y + 10, 3, 0, Math.PI * 2);
      ctx.fill();
      
      // Border accent
      ctx.strokeStyle = `rgba(0, 255, 100, ${0.4 * fadeRatio})`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.roundRect(x + 3, y + 3, 14, 14, 5);
      ctx.stroke();
    }
    
    ctx.restore();
  }
  
  // PREMIUM FOOD/APPLE
  ctx.save();
  const fx = food.x * 20;
  const fy = food.y * 20;
  
  // Outer glow pulse
  ctx.shadowColor = '#ff0000';
  ctx.shadowBlur = 40;
  ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
  ctx.beginPath();
  ctx.arc(fx + 10, fy + 12, 12, 0, Math.PI * 2);
  ctx.fill();
  
  // Main apple body
  const appleGrad = ctx.createRadialGradient(fx + 7, fy + 9, 2, fx + 10, fy + 12, 10);
  appleGrad.addColorStop(0, '#ff6666');
  appleGrad.addColorStop(0.4, '#ff3333');
  appleGrad.addColorStop(0.8, '#ee0000');
  appleGrad.addColorStop(1, '#aa0000');
  ctx.fillStyle = appleGrad;
  ctx.shadowBlur = 25;
  ctx.beginPath();
  ctx.arc(fx + 10, fy + 12, 8.5, 0, Math.PI * 2);
  ctx.fill();
  
  // Apple shine
  ctx.shadowBlur = 0;
  const shineGrad = ctx.createRadialGradient(fx + 6, fy + 8, 0, fx + 7, fy + 9, 5);
  shineGrad.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
  shineGrad.addColorStop(0.5, 'rgba(255, 255, 255, 0.4)');
  shineGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
  ctx.fillStyle = shineGrad;
  ctx.beginPath();
  ctx.arc(fx + 6.5, fy + 8.5, 4, 0, Math.PI * 2);
  ctx.fill();
  
  // Stem with gradient
  const stemGrad = ctx.createLinearGradient(fx + 9, fy + 3, fx + 11, fy + 7);
  stemGrad.addColorStop(0, '#a0522d');
  stemGrad.addColorStop(1, '#654321');
  ctx.fillStyle = stemGrad;
  ctx.fillRect(fx + 9, fy + 3, 2.5, 5);
  
  // Leaf
  const leafGrad = ctx.createLinearGradient(fx + 11, fy + 3, fx + 16, fy + 7);
  leafGrad.addColorStop(0, '#00ff00');
  leafGrad.addColorStop(0.5, '#00dd00');
  leafGrad.addColorStop(1, '#00aa00');
  ctx.fillStyle = leafGrad;
  ctx.shadowColor = '#00ff00';
  ctx.shadowBlur = 8;
  ctx.beginPath();
  ctx.ellipse(fx + 13.5, fy + 5, 3.5, 2.5, Math.PI / 4, 0, Math.PI * 2);
  ctx.fill();
  
  // Leaf vein
  ctx.shadowBlur = 0;
  ctx.strokeStyle = 'rgba(0, 150, 0, 0.6)';
  ctx.lineWidth = 0.5;
  ctx.beginPath();
  ctx.moveTo(fx + 12, fy + 5);
  ctx.lineTo(fx + 15, fy + 6);
  ctx.stroke();
  
  ctx.restore();
}

// Polyfill
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
    if (w < 2 * r) r = w/2;
    if (h < 2 * r) r = h/2;
    this.beginPath();
    this.moveTo(x+r, y);
    this.arcTo(x+w, y, x+w, y+h, r);
    this.arcTo(x+w, y+h, x, y+h, r);
    this.arcTo(x, y+h, x, y, r);
    this.arcTo(x+w, y, x+w, y, r);
    this.closePath();
    return this;
  }
}
</script>
</body>
</html>
